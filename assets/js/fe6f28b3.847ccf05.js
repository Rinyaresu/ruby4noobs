"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[757],{3905:(e,a,o)=>{o.d(a,{Zo:()=>p,kt:()=>k});var n=o(7294);function s(e,a,o){return a in e?Object.defineProperty(e,a,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[a]=o,e}function r(e,a){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),o.push.apply(o,n)}return o}function t(e){for(var a=1;a<arguments.length;a++){var o=null!=arguments[a]?arguments[a]:{};a%2?r(Object(o),!0).forEach((function(a){s(e,a,o[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(o,a))}))}return e}function d(e,a){if(null==e)return{};var o,n,s=function(e,a){if(null==e)return{};var o,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],a.indexOf(o)>=0||(s[o]=e[o]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],a.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(s[o]=e[o])}return s}var i=n.createContext({}),m=function(e){var a=n.useContext(i),o=a;return e&&(o="function"==typeof e?e(a):t(t({},a),e)),o},p=function(e){var a=m(e.components);return n.createElement(i.Provider,{value:a},e.children)},l="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var o=e.components,s=e.mdxType,r=e.originalType,i=e.parentName,p=d(e,["components","mdxType","originalType","parentName"]),l=m(o),u=s,k=l["".concat(i,".").concat(u)]||l[u]||c[u]||r;return o?n.createElement(k,t(t({ref:a},p),{},{components:o})):n.createElement(k,t({ref:a},p))}));function k(e,a){var o=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=o.length,t=new Array(r);t[0]=u;var d={};for(var i in a)hasOwnProperty.call(a,i)&&(d[i]=a[i]);d.originalType=e,d[l]="string"==typeof e?e:s,t[1]=d;for(var m=2;m<r;m++)t[m]=o[m];return n.createElement.apply(null,t)}return n.createElement.apply(null,o)}u.displayName="MDXCreateElement"},3813:(e,a,o)=>{o.r(a),o.d(a,{assets:()=>i,contentTitle:()=>t,default:()=>c,frontMatter:()=>r,metadata:()=>d,toc:()=>m});var n=o(7462),s=(o(7294),o(3905));const r={},t="Classes e Objetos",d={unversionedId:"Modulo Intermediario/classes-e-objetos",id:"Modulo Intermediario/classes-e-objetos",title:"Classes e Objetos",description:"Tudo em ruby \xe9 um objeto. Ent\xe3o vamos aprender a criar os nossos pr\xf3prios. Para isso, vamos come\xe7ar criando uma classe chamada Pessoa.",source:"@site/docs/4-Modulo Intermediario/1-classes-e-objetos.md",sourceDirName:"4-Modulo Intermediario",slug:"/Modulo Intermediario/classes-e-objetos",permalink:"/ruby4noobs/Modulo Intermediario/classes-e-objetos",draft:!1,tags:[],version:"current",lastUpdatedBy:"Sther",lastUpdatedAt:1702658494,formattedLastUpdatedAt:"15 de dez. de 2023",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"M\xe9todos",permalink:"/ruby4noobs/Basico da Linguagem/metodos"},next:{title:"Depend\xeancias",permalink:"/ruby4noobs/Modulo Intermediario/dependencias"}},i={},m=[{value:"Transformando em string",id:"transformando-em-string",level:2},{value:"attr_reader",id:"attr_reader",level:2},{value:"attr_writer",id:"attr_writer",level:2},{value:"attr_accessor",id:"attr_accessor",level:2},{value:"Vari\xe1veis de Classe",id:"vari\xe1veis-de-classe",level:2},{value:"Heran\xe7a",id:"heran\xe7a",level:2}],p={toc:m},l="wrapper";function c(e){let{components:a,...o}=e;return(0,s.kt)(l,(0,n.Z)({},p,o,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"classes-e-objetos"},"Classes e Objetos"),(0,s.kt)("p",null,"Tudo em ruby \xe9 um ",(0,s.kt)("strong",{parentName:"p"},"objeto"),". Ent\xe3o vamos aprender a criar os nossos pr\xf3prios. Para isso, vamos come\xe7ar criando uma classe chamada ",(0,s.kt)("inlineCode",{parentName:"p"},"Pessoa"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\np pessoa\nputs pessoa\n')),(0,s.kt)("p",null,"Executando o c\xf3digo acima, voc\xea vai ver que a classe ",(0,s.kt)("inlineCode",{parentName:"p"},"Pessoa")," foi criada como um objeto."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},'=> #<Pessoa:0x00007fcab271e1c8 @nome="Mc Poze do Rodo", @idade=23>\n=> #<Pessoa:0x00007fcab271e1c8>\n')),(0,s.kt)("p",null,"Como visto acima, Para criarmos uma classe, usamos a palavra-chave ",(0,s.kt)("inlineCode",{parentName:"p"},"class"),", seguida pelo nome da classe."),(0,s.kt)("p",null,"Segundo as conven\xe7\xf5es de ",(0,s.kt)("strong",{parentName:"p"},"Ruby"),", nos nomes das classes \xe9 utilizado ",(0,s.kt)("a",{parentName:"p",href:"https://pt.wikipedia.org/wiki/CamelCase"},"camel case"),", da mesma maneira que em ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/paulorievrs/java4noobs/blob/master/4%20-%20Intermedi%C3%A1rio/04-PrimeiraClasse.md"},"Java"),", com mai\xfasculas separando duas ou mais palavras no nome da classe. Temos ent\xe3o classes com nomes como ",(0,s.kt)("inlineCode",{parentName:"p"},"CachorroCaramelo"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"CarroPersonalizado"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"MeuComputador"),"."),(0,s.kt)("p",null,"As propriedades do nosso objeto s\xe3o armazenadas no que j\xe1 explicamos antes e chamamos de ",(0,s.kt)("a",{parentName:"p",href:"/ruby4noobs/Basico%20da%20Linguagem/variaveis"},"vari\xe1veis de inst\xe2ncia"),", que s\xe3o vari\xe1veis dentro do objeto cujo nome se inicia com ",(0,s.kt)("inlineCode",{parentName:"p"},"@"),". Se fizermos refer\xeancia para alguma que ainda n\xe3o foi criada, ",(0,s.kt)("strong",{parentName:"p"},"ela ser\xe1"),"."),(0,s.kt)("p",null,"Podemos inicializar v\xe1rias dessas vari\xe1veis dentro do m\xe9todo ",(0,s.kt)("inlineCode",{parentName:"p"},"initialize"),", que \xe9 o construtor do nosso objeto, chamado ap\xf3s o m\xe9todo ",(0,s.kt)("inlineCode",{parentName:"p"},"new"),", que aloca espa\xe7o na mem\xf3ria para o objeto sendo criado."),(0,s.kt)("h2",{id:"transformando-em-string"},"Transformando em string"),(0,s.kt)("p",null,"Podemos ver acima que usando ",(0,s.kt)("inlineCode",{parentName:"p"},"puts")," para verificar o nosso ",(0,s.kt)("strong",{parentName:"p"},"objeto"),", foi mostrada somente a refer\xeancia dele na mem\xf3ria. Mas, para vermos o objeto completo, precisamos transformar o objeto em string."),(0,s.kt)("p",null,"Vamos fazer um m\xe9todo novo na classe para mostrar as informa\xe7\xf5es de uma maneira mais bonita. Se lembra que em ",(0,s.kt)("a",{parentName:"p",href:"/ruby4noobs/Basico%20da%20Linguagem/tipos-de-dados"},"tipos de dados")," utilizamos um m\xe9todo chamado ",(0,s.kt)("inlineCode",{parentName:"p"},"to_s"),", que converte o objeto em uma ",(0,s.kt)("inlineCode",{parentName:"p"},"String"),"? Vamos usar ele."),(0,s.kt)("p",null,"Vamos criar um m\xe9todo para a nossa classe:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\np pessoa\nputs pessoa\n')),(0,s.kt)("p",null,"Executando o c\xf3digo acima, voc\xea vai ver que a classe ",(0,s.kt)("inlineCode",{parentName:"p"},"Pessoa")," foi criada como um objeto, e como o m\xe9todo ",(0,s.kt)("inlineCode",{parentName:"p"},"to_s")," foi criado, ele foi chamado automaticamente."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},'=> #<Pessoa:0x00007f533fb23178 @nome="Mc Poze do Rodo", @idade=23>\n=> Nome: Mc Poze do Rodo Idade: 23\n')),(0,s.kt)("h2",{id:"attr_reader"},"attr_reader"),(0,s.kt)("p",null,"Anteriormente vimos como criar nossos ",(0,s.kt)("strong",{parentName:"p"},"objetos")," e suas propriedades usando vari\xe1veis de inst\xe2ncia, mas nos podemos l\xea-las?"),(0,s.kt)("p",null,"Vamos acess\xe1-las usando as nossas vari\xe1veis de inst\xe2ncia:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\nputs pessoa.nome\nputs pessoa.idade\n')),(0,s.kt)("p",null,"Ops.."),(0,s.kt)("p",null,"Executando o c\xf3digo acima, voc\xea vai ver que a recebemos um ",(0,s.kt)("strong",{parentName:"p"},"erro"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},"=> undefined method 'nome' for #<Pessoa:0x00007f533fa44888 @nome=\"Mc Poze do Rodo\", @idade=23> (NoMethodError)\n\n=> undefined method 'idade' for #<Pessoa:0x00007f533fa44888 @nome=\"Mc Poze do Rodo\", @idade=23> (NoMethodError)\n")),(0,s.kt)("p",null,"Essas vari\xe1veis s\xe3o privadas do ",(0,s.kt)("strong",{parentName:"p"},"objeto"),", e n\xe3o podem ser lidas sem um m\xe9todo de acesso. Ent\xe3o nos podemos resolver isso usando ",(0,s.kt)("inlineCode",{parentName:"p"},"attr_reader"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  attr_reader :nome, :idade\n\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\nputs pessoa.nome\nputs pessoa.idade\n')),(0,s.kt)("p",null,"Executando o c\xf3digo agora nos vamos ter a resposta esperada:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},"=> Mc Poze do Rodo\n=> 23\n")),(0,s.kt)("h2",{id:"attr_writer"},"attr_writer"),(0,s.kt)("p",null,"E se agora nos quisermos trocar o nome ou a idade usando as vari\xe1veis?"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  attr_reader :nome, :idade\n\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\npessoa.idade = 24\n')),(0,s.kt)("p",null,"Executando o c\xf3digo acima, voc\xea vai ver que recebemos um erro de ",(0,s.kt)("inlineCode",{parentName:"p"},"undefined method"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-irb"},'=> undefined method `idade=\' for #<Pessoa:0x00007f548af5c7c0 @nome="Mc Poze do Rodo", @idade=23> (NoMethodError)\n')),(0,s.kt)("p",null,"No exemplo do ",(0,s.kt)("inlineCode",{parentName:"p"},"attr_reader")," criamos ",(0,s.kt)("strong",{parentName:"p"},"atributos de leitura"),", que nos permitem a leitura da propriedade. Se precisarmos de algum ",(0,s.kt)("strong",{parentName:"p"},"atributo de escrita"),", para trocarmos a ",(0,s.kt)("inlineCode",{parentName:"p"},"idade")," ou ",(0,s.kt)("inlineCode",{parentName:"p"},"nome")," da ",(0,s.kt)("inlineCode",{parentName:"p"},"Pessoa"),", podemos usar:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  attr_reader :nome, :idade\n  attr_writer :idade\n\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\npessoa.idade = 24\nputs pessoa\n')),(0,s.kt)("p",null,"Executando o c\xf3digo agora nos vamos ter a resposta esperada:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},"=> Nome: Mc Poze do Rodo Idade: 24\n")),(0,s.kt)("h2",{id:"attr_accessor"},"attr_accessor"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"attr_accessor")," \xe9 um m\xe9todo que nos ajuda a fazer o que foi ensinado acima de uma forma mais f\xe1cil e menos repetitiva. Como por exemplo:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  attr_accessor :nome, :idade\n\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\npessoa.idade = 21\npessoa.nome = "MC Poze Pitbull do Funk"\nputs pessoa\n')),(0,s.kt)("p",null,"Executando o c\xf3digo agora nos vamos ter a resposta esperada:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},"=> Nome: MC Poze Pitbull do Funk Idade: 21\n")),(0,s.kt)("h2",{id:"vari\xe1veis-de-classe"},"Vari\xe1veis de Classe"),(0,s.kt)("p",null,"Tamb\xe9m podemos criar ",(0,s.kt)("a",{parentName:"p",href:"/ruby4noobs/Basico%20da%20Linguagem/variaveis"},"vari\xe1veis de classe"),", que s\xe3o vari\xe1veis que s\xe3o compartilhadas por todos os objetos da classe."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  attr_accessor :nome, :idade\n  @@contador = 0\n\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n    @@contador += 1\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\n\n  def self.contador # utilizando self para n\xe3o precisar de um objeto para acessar a vari\xe1vel de classe. Sem o self iriamos precisar usar o objeto Poze.contador para acessar a vari\xe1vel de classe.\n    @@contador\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\n\nputs Pessoa.contador\n')),(0,s.kt)("p",null,"Executando o c\xf3digo nos vamos ter a resposta esperada:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},"=> 1\n")),(0,s.kt)("h2",{id:"heran\xe7a"},"Heran\xe7a"),(0,s.kt)("p",null,"Em Ruby, temos ",(0,s.kt)("em",{parentName:"p"},"heran\xe7a \xfanica"),", que significa que uma classe pode apenas ser criada herdando de apenas outra classe, reduzindo a complexidade do c\xf3digo.\nDessa forma, podemos ao inv\xe9s de repetir a defini\xe7\xe3o de m\xe9todos por classes similares, pode realizar essa opera\xe7\xe3o em uma \xfanica classe (tamb\xe9m chamada de ",(0,s.kt)("strong",{parentName:"p"},"superclasse"),") e as outras que possuem m\xe9todos comuns (chamadas de ",(0,s.kt)("strong",{parentName:"p"},"subclasses"),") herdam essas funcionalidades da sua superclasse. ",(0,s.kt)("strong",{parentName:"p"},"A heran\xe7a ajuda a reduzir substancialmente a duplica\xe7\xe3o de c\xf3digo.")," Como por exemplo:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ruby"},'class Pessoa\n  attr_accessor :nome, :idade\n  @@contador = 0\n\n  def initialize(nome, idade)\n    @nome = nome\n    @idade = idade\n    @@contador += 1\n  end\n\n  def to_s\n  "Nome: #{@nome} Idade: #{@idade}"\n  end\n\n  def self.contador\n    @@contador\n  end\nend\n\nclass OutraPessoa < Pessoa\n  def to_s\n    "Outra pessoa: #{super}"\n  end\nend\n\npessoa = Pessoa.new("Mc Poze do Rodo", 23)\npessoa2 = OutraPessoa.new("Beethoven", 56)\n\nputs pessoa\nputs pessoa2\n')),(0,s.kt)("p",null,"Executando o c\xf3digo nos vamos ter a resposta esperada:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-txt"},"=> Nome: Mc Poze do Rodo Idade: 23\n=> Outra pessoa: Nome: Beethoven Idade: 56\n")),(0,s.kt)("p",null,"Espero que tenha entendido como funcionam ",(0,s.kt)("strong",{parentName:"p"},"classes e objetos em ruby"),". Isso n\xe3o \xe9 tudo desse tema, mas \xe9 o suficiente para que voc\xea possa come\xe7ar a aprender a programar usando classes e objetos. \ud83d\ude09"))}c.isMDXComponent=!0}}]);